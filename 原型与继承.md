#  原型与继承

**prototype ：**只有**函数**才会有 prototype 属性，它引用了一个对象。只要创建一个新函数，JS引擎会根据一组特定的规则为该函数创建一个 prototype 对象。

**constructor：**prototype 对象初始化时有一个属性 constructor，用来引用函数。

**proto：**任何**对象**都有__proto__属性，指向构造函数的 prototype 对象

**原型继承：**1.实例继承原型的属性，可以访问这个属性，就像本身拥有该属性一样。

​                   2.构造函数与原型方法中的 this，**指向当前的实例**。

**继承：**1.属性的继承只发生在读属性时，而在写属性值时不会发生。
            2.读属性时，JavaScript 首先从本对象查找，接着是它的原型，以及原型的原型，直到原型链的顶端。
            3.可以访问原型链上的任何一个属性，就好像对象本身拥有该属性一样。

**属性访问机制：**当通过对象访问属性时，JavaScript 首先从**本对象**查找，接着是它的**原型**，以及**原型的原型**。即按照**原型链**查找属性。

**属性屏蔽：**当在**本对象和原型对象具有相同的属性**时，不会再去原型上访问。也就是说本对象“遮蔽”或者“隐藏”了原型对象中的属性。

**覆写：**一个对象的属性可以**覆写原型对象相同键**的属性。此时，前者的属性最被找到，可以**隐藏原型对象的属性**，使得原型对象的属性不能被访问。

**属性分类：**1.**自有属性**：指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性

**obj.hasOwnProperty(prop):** 返回一个**布尔值**，指示对象自身属性中是否具有指定的属性
 prop —— 要检测的属性字符串名 
 **Object.getOwnPropertyNames(obj):**返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的**数组**。

​                   2.**继承属性**:从原型链上查找的属性

**遍历属性：**1.列出所有**自有**属性键 
 **Object.getOwnPropertyNames(obj)：**返回一个由指定对象的所有自身属性的属性名（**包括不可枚举属性**）组成的数组。
 **Object.keys(obj)：**返回一个由指定对象的所有自身属性的属性名（**不包括不可枚举属性**）组成的数组

​                    2.列出所有属性键 （**包括自有和继承**）
 **for  in 循环：**遍历一个对象的所有可枚举属性键

**检测属性：**1.**obj.hasOwnProperty(prop)** 
                   2.**prop  in  obj：** **obj** —— 检查它（或其原型链）是否包含具有指定名称的属性的对象。(如果指定的属性在指定的对象或其原型链中，则 in 运算符返回 true。)

**原型链：**1.每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 
               2.解释了为何一个对象会拥有定义在其他对象中的属性和方法

​               3.每个实例对象（object ）都有一个属性（__proto__）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。
​               4.可通过实例化出来的对象的__proto__属性来确认原型

​               5.所有对象具有 __proto__ 属性。
​               6.函数具有 prototype 属性，Function.prototype 是例外，虽然是函数，但是不具有 prototype 属性，函数具有prototype、__proto__属性。
​               7.Function created by Function  Function.__proto__==Function.prototype
​               8.Object created  by Function  Object.__proto__==Function.prototype

​               9.Function.prototype.__proto__ == Object.prototype，给 Object.prototype 添加方法和属性，Function.prototype也会拥有相同的方法和属性，相反则不具有
​               10.Function.prototype 是函数的起源，Object.prototype 是对象的起源，函数也是对象，是对象中的一等公民。

**获取原型对象：**Object.getPrototypeOf(obj) ：返回指定对象的原型，如果没有继承属性，则返回 null 。

**设置原型对象：**Object.create(proto)：创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

**判断原型对象：**prototypeObj.isPrototypeOf(object)： 测试 prototypeObj 对象是否存在 object 对象的原型链上。

**数据类型检测：**1.**typeof**

​                           2.**constructor**：对象的 constructor 属性用于返回创建该对象的函数，也就是我们常说的构造函数。 在 JavaScript 中，通过构造函数创建的实例对象可以访问原型对象的constructor 属性。

​                           3.**object instanceof constructor**：测试 constructor 构造函数的 prototype 对象是否出现在object 对象的原型链中的任何位置
 **object** —— 要检测的对象
 **constructor** —— 某个构造函数 

​                           4. **toString**：使用 call（必须通过 call 或 apply 来调用，而不能直接调用 toString） 来调用该方法会返回调用者的类型字符串，格式为 [object,xxx]，xxx 是调用者的数据类型，基本上，所有的数据类型都可以通过这个方法获取到。

