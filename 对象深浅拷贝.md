# 对象深浅拷贝

**递归：**一个方法重复调用自身的情况叫做递归（一定要有一个条件来结束递归，否则将会陷入无限的循环）

function f(n){

​     if（约束条件）return n；

​     return 函数运算结果；

}

**引用类型存储：**1.对象的**引用（地址）值**复制给变量对象 b，变量对象 b 和对象 a 都**指向同一个空间**，**相互影响**。

​                          2.对于引用类型的复制，简单赋值无用，**需要拷贝**。拷贝存在两种类型：深拷贝与浅拷贝

**深浅拷贝：**

1.**浅拷贝:**拷贝**基本类型**的值,拷贝引用类型的**引用（地址)**

浅拷贝不是直接赋值，浅拷贝**新建了一个对象**，然后将源对象的**属性**都一一**复制**过来。

对象拷贝时，如果属性是**对象或数组**时，这时候我们**传递**的只是一个**地址**。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，**两者的属性值会指向同一内存空间**。

2.**深拷贝** **= 浅拷贝 + 递归**

拷贝基本类型的值，拷贝**引用类型**时（比如**数组和或对象**），使用**递归**，把父对象中所有属于引用类型的对象都**遍历**赋给子对象即可。

**拷贝person1：**1.生成新的对象person2（开辟空间）

​                         2.判断person1里的数据类型

​                         3.基本数据类型：直接赋值

​                            引用类型：判断[],{},|| （判断person1里是数组或对象：**constructor方法** 数组：[]  对象：{}  **开辟新空间**）   遍历属性值（递归判断：直到每一个对象都是基本数据类型是结束）





