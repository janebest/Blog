# 事件与事件流

**事件绑定**

**内联模型**

```
<button onclick="tell();">弹出提示框</button>
```

 违反了“内容与行为相分离的原则”，尽量少用

 **脚本模型**

```
document.getElementById('btn').onclick = function(){  }
```

实现了“内容与行为相分离”但元素只能绑定一个监听函数

具名函数可删除，匿名函数不可删除

**关系节点**

parentNode.getElementsByTagName( )
parentNode.getElementsByClassName( )

**获取元素节点**

document.**querySelector**(selectors) 
 selectors：有效的 CSS 选择器字符串
                   返回文档中与指定选择器或选择器组匹配的第一个 html 元素 Element。
                    如果找不到匹配项，则返回 null。
 document.**querySelectorAll**(selectors)
 parentNode.querySelector(selectors)
 parentNode.querySelectorAll(selectors)

**事件流**

1.**描述从页面接受事件的顺序**：当几个都具有事件的元素层叠在一起的时候，那么你点击其中一个元素，并不是只有当前被点击的元素会触发事件，而层叠在你点击范围的所有元素都会触发事件。
2.事件流包括两种模式：**冒泡和捕获**（现代浏览器默认情况下都是冒泡模型，IE 不支持捕获，只支持冒泡。）

**JavaScript 中的事件冒泡顺序为：**button — div — body — html — document

**阻止事件冒泡：**event.stopPropagation();

**冒泡事件**

event.**bubbles**（返回一个布尔值，表明当前事件是否会向 DOM 树上层元素冒泡）
onmouseover onmouseout —— 支持冒泡
**onmouseenter onmouseleave —— 不支持冒泡**

 **事件委托（event delegation）**：将事件监听器设置在其父节点上，并将事件监听器的影响设置为每个子节点，而不是每个子节点单独设置事件监听器

**捕获设置**

element.**addEventListener**(type， listener[， useCapture])
useCapture：布尔值，指定事件是否在捕获或冒泡阶段触发
true，指定事件在捕获阶段执行
false，指定事件在冒泡阶段执行，默认

**删除：**removeEventListener(type，listener)

**事件处理周期**

 触发一个事件后，在 HTML 元素间进行传播过程
 第一阶段：事件的**捕获**，事件对象沿 DOM 树**向下**传播
 第二阶段：目标触发，执行事件监听函数
 **第三阶段：事件冒泡，事件沿 DOM 树向上传播**

**自定义事件步骤：**

创建自定义事件类型
 元素监听事件
 元素派发事件

**EventTarget 对象：**是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。Element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如 XMLHttpRequest。许多事件目标（包括元素，文档和 window）还支持通过 on... 属性设置事件处理程序。
向一个指定的事件目标**派发一个事件**： dispatchEvent()

**CustomEvent( type [，customEventInit ] )**
 type：事件的类型名称
 customEventInit       { canBubble，cancelable，detail } 
 canBubble：一个布尔值,表明该事件是否会冒泡
 cancelable：一个布尔值,表明该事件是否可以被取消
 detail：当事件初始化时传递的数据

**事件轮询（Event Loop）**

任务可以分成两种
**同步任务**指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
**异步任务**指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

主线程重复从消息队列中取消息、执行的过程。

















