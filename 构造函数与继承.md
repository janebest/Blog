# 构造函数与继承

**构造函数：** 1.构造函数的**首字母必须大写**，用来区分于普通函数
                    2.内部使用的 **this** 对象，来指向即将要**生成的实例对象**
                    3.使用 **New** 来生成实例对象

**实例化与内存：**1.实例化即**创建一个变量**的过程，是将对象**复制**一个副本
                          2.然后**通过构造函数**来对这个占有独立空间的变量**进行初始化**

**实例化过程：**1.**创建**（或者说构造）一个全新的对象。
                      2.这个新对象会被**执行 [[ 原型 ]] 连接**。
                      3.这个新对象会**绑定**到函数调用的 **this**。
                      4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回 this (新对象)。

**封装一个_new函数：**new函数需要传入以下几个参数:第一个参数：**构造函数名Func**；第二个参数及后面的参数：**构造函数的参数**

```
`function` `_new(){``　``//1.拿到传入的参数中的第一个参数，即构造函数名Func``　 ``var` `Func = [].shift.call(arguments);``　　``//2.创建一个空对象obj,并让其继承Func.prototype``　　``var` `obj = Object.create(Func.prototype);``　　``//3.执行构造函数，并将this指向创建的空对象obj``　　Func.apply(obj,arguments)``　　``//4.返回创建的对象obj``　　``return` `obj``}`
```

**通过原型在对象间共享数据：**1.所有的实例对象都可以获取构造器函数中的属性和方法。但是，同一个对象实例之间，无法共享属性。
                                               2.所有实例都会通过原型链引用到 prototype 对象，prototype 引用对象相当于特定类型所有实例都可以访问到的一个公共容器，我们可以把重复的东西放到公共容器。

**函数返回值：**1.函数如果没有 return ，默认返回 **undefined**；
                      2.如果使用了 return，那返回值为根据 **return 后面的表达式的值**。

**构造函数返回值：**1.构造函数**没有 return**，会默认**返回** **this**，也就是新的实例对象；
                             2.如果使用了 return，且返回值为**基本数据类型**，构造函数会忽略 return的值，依然**返回 this 对象**；
                             3.如果使用了 return，且返回值为**引用数据类型**，构造函数会**返回 return 的值**。

**属性:**1.实例能够访问原型属性，但是不能访问静态属性。
         2.静态属性只能通过构造函数来访问。

**属性分类:**1.数据属性，访问器属性，内置属性

​                2.自有属性，继承属性

​                3.实例属性，静态属性，原型属性

 **继承：**继承属性和方法

1.**构造继承**：通过使用 call、apply 方法可以在新创建的对象上执行构造函数，用父类的构造函数来增加子类的实例（直接继承父类构造函数的属性和方法。，但是无法继承原型链上的属性和方法）

2.**原型继承：**原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。（实例是子类的实例，也是父类的一个实例，父类新增原型方法/原型属性，子类都能访问到）

3.**组合继承：**利用构造继承和原型继承组合

4.**原型式继承：**采用原型式继承并不需要定义一个构造函数，传入参数obj，生成一个继承 obj 对象的对象

5.**Object.create(obj)：**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__

**实例的方法：**实例对象中的方法可以写在构造函数内，也可以写在构造函数prototype 属性上。
 1.把方法写在构造函数内的情况我们简称为函数内方法：会在它的每一个实例上都克隆这个方法，内存占用就比较大，但可以访问函数内部的私有变量。

2.把方法写在 prototype 属性上的情况我们简称为 prototype上的方法：定义在构造函数的 prototype 属性上的方法会让它的所有示例都共享这个方法，但是不会在每个实例的内部重新定义这个方法，内存占用就比较小，但不可以访问函数内部的私有变量。